#if UNITY_IOS
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEditor.iOS.Xcode;
using UnityEngine;
using System.IO;

/// <summary>
/// iOS post process step that:
/// - Looks in Assets/AppIcon for an Icon Composer .icon bundle
/// - Copies that .icon bundle to the root of the Xcode build folder
/// - Adds it to the Xcode project
/// - Sets it as the App Icon:
///     CFBundleIconName = <file-name-without-extension>
///     ASSETCATALOG_COMPILER_APPICON_NAME = <same-name>
/// 
/// Works with Xcode 26+ / Icon Composer icons.
/// </summary>
public static class IOSIconComposerIcon
{
    /// <summary>
    /// Folder in the Unity project that should contain your .icon bundle(s).
    /// Example structure:
    ///     Assets/AppIcon/MyCoolApp.icon
    /// </summary>
    private const string SourceIconFolderRelativePath = "Assets/AppIcon";

    [PostProcessBuild(100)]
    public static void OnPostProcessBuild(BuildTarget target, string pathToBuiltProject)
    {
        if (target != BuildTarget.iOS)
            return;

        // 1) Find a .icon bundle under Assets/AppIcon
        string iconFolderFullPath = Path.GetFullPath(SourceIconFolderRelativePath);
        if (!Directory.Exists(iconFolderFullPath))
        {
            Debug.LogWarning($"[IconComposer] Source folder not found: {iconFolderFullPath}");
            return;
        }

        string iconFullPath;
        string iconFileName;
        string iconNameWithoutExt;

        if (!TryFindIconBundle(iconFolderFullPath, out iconFullPath, out iconFileName, out iconNameWithoutExt))
        {
            Debug.LogWarning($"[IconComposer] No .icon bundle found in: {iconFolderFullPath}");
            return;
        }

        Debug.Log($"[IconComposer] Using .icon bundle: {iconFullPath}");

        bool isDir  = Directory.Exists(iconFullPath);
        bool isFile = File.Exists(iconFullPath);

        // 2) Copy the .icon bundle to the root of the Xcode build folder
        string destPath = Path.Combine(pathToBuiltProject, iconFileName);

        if (isDir)
        {
            if (Directory.Exists(destPath))
                Directory.Delete(destPath, true);

            CopyDirectory(iconFullPath, destPath);
            Debug.Log($"[IconComposer] Copied bundle to: {destPath}");
        }
        else if (isFile)
        {
            File.Copy(iconFullPath, destPath, true);
            Debug.Log($"[IconComposer] Copied file to: {destPath}");
        }
        else
        {
            Debug.LogWarning($"[IconComposer] Path is neither file nor directory: {iconFullPath}");
            return;
        }

        // 3) Open Xcode project (pbxproj)
        string projPath = PBXProject.GetPBXProjectPath(pathToBuiltProject);
        var proj = new PBXProject();
        proj.ReadFromFile(projPath);

#if UNITY_2019_3_OR_NEWER
        string mainTarget      = proj.GetUnityMainTargetGuid();
        string frameworkTarget = proj.GetUnityFrameworkTargetGuid();
#else
        string mainTarget      = proj.TargetGuidByName("Unity-iPhone");
        string frameworkTarget = proj.TargetGuidByName("UnityFramework");
#endif

        // 4) Add .icon bundle to the Xcode project and build phase
        string relPathInProj = iconFileName; // e.g. "SpatialSense.icon" in project root
        string fileGuid = proj.FindFileGuidByProjectPath(relPathInProj);
        if (string.IsNullOrEmpty(fileGuid))
        {
            fileGuid = proj.AddFile(relPathInProj, relPathInProj, PBXSourceTree.Source);
            Debug.Log($"[IconComposer] Added {iconFileName} to the Xcode project.");
        }

        proj.AddFileToBuild(mainTarget, fileGuid);

        // 5) Set build properties so Xcode shows the correct App Icon name
        proj.SetBuildProperty(mainTarget,      "ASSETCATALOG_COMPILER_APPICON_NAME", iconNameWithoutExt);
        proj.SetBuildProperty(frameworkTarget, "ASSETCATALOG_COMPILER_APPICON_NAME", iconNameWithoutExt);

        // Optional, but keeps things in sync with Info.plist
        proj.SetBuildProperty(mainTarget, "INFOPLIST_KEY_CFBundleIconName", iconNameWithoutExt);

        proj.WriteToFile(projPath);

        // 6) Patch Info.plist: CFBundleIconName and remove Unity's CFBundleIcons block
        string plistPath = Path.Combine(pathToBuiltProject, "Info.plist");
        if (File.Exists(plistPath))
        {
            var plist = new PlistDocument();
            plist.ReadFromFile(plistPath);

            PlistElementDict root = plist.root;
            root.SetString("CFBundleIconName", iconNameWithoutExt);

            // Remove old icon config generated by Unity, if present
            if (root.values.ContainsKey("CFBundleIcons"))
                root.values.Remove("CFBundleIcons");

            File.WriteAllText(plistPath, plist.WriteToString());
            Debug.Log($"[IconComposer] Info.plist: CFBundleIconName => {iconNameWithoutExt}");
        }
        else
        {
            Debug.LogWarning("[IconComposer] Info.plist not found, CFBundleIconName was not updated.");
        }
    }

    /// <summary>
    /// Looks for a .icon bundle in the given folder.
    /// Returns the first match (alphabetically).
    /// Unity usually imports .icon as a folder, so we check directories first.
    /// </summary>
    private static bool TryFindIconBundle(string folder, out string fullPath, out string fileName, out string nameWithoutExt)
    {
        fullPath = null;
        fileName = null;
        nameWithoutExt = null;

        // Directories that end with .icon
        string[] dirCandidates = Directory.GetDirectories(folder, "*.icon", SearchOption.TopDirectoryOnly);
        // Files that end with .icon (fallback)
        string[] fileCandidates = Directory.GetFiles(folder, "*.icon", SearchOption.TopDirectoryOnly);

        string chosen = null;

        if (dirCandidates.Length > 0)
        {
            System.Array.Sort(dirCandidates);
            chosen = dirCandidates[0];
        }
        else if (fileCandidates.Length > 0)
        {
            System.Array.Sort(fileCandidates);
            chosen = fileCandidates[0];
        }

        if (string.IsNullOrEmpty(chosen))
            return false;

        fullPath       = chosen;
        fileName       = Path.GetFileName(chosen);               // e.g. "MyIcon.icon"
        nameWithoutExt = Path.GetFileNameWithoutExtension(chosen); // e.g. "MyIcon"
        return true;
    }

    private static void CopyDirectory(string sourceDir, string destDir)
    {
        Directory.CreateDirectory(destDir);

        foreach (var file in Directory.GetFiles(sourceDir))
        {
            var name = Path.GetFileName(file);
            File.Copy(file, Path.Combine(destDir, name), true);
        }

        foreach (var dir in Directory.GetDirectories(sourceDir))
        {
            var name = Path.GetFileName(dir);
            string subDest = Path.Combine(destDir, name);
            CopyDirectory(dir, subDest);
        }
    }
}
#endif